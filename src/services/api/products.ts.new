import axios from 'axios';
import { Product, PaginatedProducts, ProductFilterOptions } from '../../types/product';
import productsMock from '../../mocks/products.mock.json';

// Always use mock data for now to avoid CORS issues
const useMockData = true; // Set to false when you have a production API with CORS configured

// Helper to detect environment
const isLocalDev = typeof window !== 'undefined' && (
  window.location.hostname === 'localhost' || 
  window.location.hostname === '127.0.0.1' ||
  window.location.hostname.endsWith('.vercel.app')
);

// Use relative URL for API in production to avoid CORS issues
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || (isLocalDev ? 'http://localhost:3000/api' : '/api');
const PRODUCTS_ENDPOINT = `${API_BASE_URL}/products`;

export interface GetProductsParams {
  page?: number;
  limit?: number;
  category?: string;
  brand?: string;
  minPrice?: number;
  maxPrice?: number;
  rating?: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  inStock?: boolean;
  onSale?: boolean;
  featured?: boolean;
  tags?: string[];
}

// Type assertion for mock data
const typedProductsMock = productsMock as unknown as Product[];

export const productService = {
  // Get all products with pagination and filtering
  async getProducts(params: GetProductsParams = {}): Promise<PaginatedProducts> {
    if (useMockData || isLocalDev) {
      // Filter products based on params
      let filteredProducts = [...typedProductsMock];
      
      if (params.category) {
        filteredProducts = filteredProducts.filter(
          p => p.category.toLowerCase() === params.category!.toLowerCase()
        );
      }
      
      if (params.brand) {
        filteredProducts = filteredProducts.filter(
          p => p.brand?.toLowerCase() === params.brand!.toLowerCase()
        );
      }
      
      if (params.minPrice !== undefined) {
        filteredProducts = filteredProducts.filter(p => p.price >= (params.minPrice || 0));
      }
      
      if (params.maxPrice !== undefined) {
        filteredProducts = filteredProducts.filter(p => p.price <= (params.maxPrice || Infinity));
      }
      
      if (params.rating) {
        filteredProducts = filteredProducts.filter(p => p.rating >= (params.rating || 0));
      }
      
      if (params.onSale) {
        filteredProducts = filteredProducts.filter(p => p.isOnSale === true);
      }
      
      if (params.featured) {
        filteredProducts = filteredProducts.filter(p => p.isFeatured === true);
      }
      
      if (params.inStock) {
        filteredProducts = filteredProducts.filter(p => p.stock > 0);
      }
      
      if (params.search) {
        const searchTerm = params.search.toLowerCase();
        filteredProducts = filteredProducts.filter(
          p => p.name.toLowerCase().includes(searchTerm) ||
               p.description.toLowerCase().includes(searchTerm)
        );
      }
      
      // Sort products
      if (params.sortBy) {
        const sortOrder = params.sortOrder || 'asc';
        filteredProducts.sort((a, b) => {
          let comparison = 0;
          const aValue = (a as any)[params.sortBy!];
          const bValue = (b as any)[params.sortBy!];
          
          if (aValue > bValue) comparison = 1;
          if (aValue < bValue) comparison = -1;
          
          return sortOrder === 'asc' ? comparison : -comparison;
        });
      }
      
      // Pagination
      const page = params.page || 1;
      const limit = params.limit || 12;
      const total = filteredProducts.length;
      const totalPages = Math.ceil(total / limit);
      const paginatedProducts = filteredProducts.slice(
        (page - 1) * limit,
        page * limit
      );
      
      return {
        products: paginatedProducts,
        total,
        page,
        limit,
        totalPages,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1
      };
    }
    
    try {
      const response = await axios.get<PaginatedProducts>(PRODUCTS_ENDPOINT, { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching products:', error);
      // Return empty result set in case of error
      return {
        products: [],
        total: 0,
        page: 1,
        limit: params.limit || 12,
        totalPages: 1,
        hasNextPage: false,
        hasPreviousPage: false
      };
    }
  },

  // Get a single product by ID or slug
  async getProductById(idOrSlug: string): Promise<Product> {
    if (useMockData || isLocalDev) {
      const product = typedProductsMock.find(
        p => p.id === idOrSlug || p.slug === idOrSlug
      );
      
      if (!product) {
        throw new Error(`Product with ID/slug ${idOrSlug} not found`);
      }
      
      return product;
    }
    
    try {
      const response = await axios.get<Product>(`${PRODUCTS_ENDPOINT}/${idOrSlug}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching product with ID/slug ${idOrSlug}:`, error);
      throw error;
    }
  },

  // Get featured products
  async getFeaturedProducts(limit: number = 8): Promise<Product[]> {
    if (useMockData || isLocalDev) {
      return typedProductsMock
        .filter(product => product.isFeatured)
        .slice(0, limit);
    }
    
    try {
      const response = await axios.get<Product[]>(`${PRODUCTS_ENDPOINT}/featured`, {
        params: { limit }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching featured products:', error);
      return [];
    }
  },

  // Get new arrivals
  async getNewArrivals(limit: number = 8): Promise<Product[]> {
    if (useMockData || isLocalDev) {
      return [...typedProductsMock]
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, limit);
    }
    
    try {
      const response = await axios.get<Product[]>(`${PRODUCTS_ENDPOINT}/new-arrivals`, {
        params: { limit }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching new arrivals:', error);
      return [];
    }
  },

  // Get products on sale
  async getOnSaleProducts(limit: number = 8): Promise<Product[]> {
    if (useMockData || isLocalDev) {
      return typedProductsMock
        .filter(product => product.isOnSale)
        .slice(0, limit);
    }
    
    try {
      const response = await axios.get<Product[]>(`${PRODUCTS_ENDPOINT}/on-sale`, {
        params: { limit }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching products on sale:', error);
      return [];
    }
  },

  // Get related products
  async getRelatedProducts(
    productId: string,
    category: string,
    limit: number = 4
  ): Promise<Product[]> {
    if (useMockData || isLocalDev) {
      return typedProductsMock
        .filter(p => p.category === category && p.id !== productId)
        .slice(0, limit);
    }
    
    try {
      const response = await axios.get<Product[]>(`${PRODUCTS_ENDPOINT}/${productId}/related`, {
        params: { category, limit }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching related products:', error);
      return [];
    }
  },

  // Get filter options
  async getFilterOptions(): Promise<ProductFilterOptions> {
    if (useMockData || isLocalDev) {
      const categories = Array.from(new Set(typedProductsMock.map(p => p.category)));
      const brands = Array.from(new Set(typedProductsMock.map(p => p.brand).filter(Boolean))) as string[];
      const prices = typedProductsMock.map(p => p.price);
      const tags = Array.from(
        new Set(typedProductsMock.flatMap(p => p.tags || []))
      ) as string[];

      return {
        categories,
        brands,
        minPrice: Math.min(...prices),
        maxPrice: Math.max(...prices),
        ratings: [1, 2, 3, 4, 5],
        tags,
      };
    }
    
    try {
      const response = await axios.get<ProductFilterOptions>(`${PRODUCTS_ENDPOINT}/filters`);
      return response.data;
    } catch (error) {
      console.error('Error fetching filter options:', error);
      return {
        categories: [],
        brands: [],
        minPrice: 0,
        maxPrice: 1000,
        ratings: [1, 2, 3, 4, 5],
        tags: []
      };
    }
  },

  // Search products
  async searchProducts(
    query: string,
    params: Omit<GetProductsParams, 'search'> = {}
  ): Promise<PaginatedProducts> {
    if (useMockData || isLocalDev) {
      const searchTerm = query.toLowerCase();
      const filtered = typedProductsMock.filter(
        product =>
          product.name.toLowerCase().includes(searchTerm) ||
          product.description.toLowerCase().includes(searchTerm) ||
          product.category.toLowerCase().includes(searchTerm) ||
          (product.brand && product.brand.toLowerCase().includes(searchTerm)) ||
          (product.tags && product.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
      );

      const page = params.page || 1;
      const limit = params.limit || 12;
      const total = filtered.length;
      const totalPages = Math.ceil(total / limit);

      return {
        products: filtered.slice((page - 1) * limit, page * limit),
        total,
        page,
        limit,
        totalPages,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1,
      };
    }
    
    try {
      const response = await axios.get<PaginatedProducts>(`${PRODUCTS_ENDPOINT}/search`, {
        params: { ...params, query }
      });
      return response.data;
    } catch (error) {
      console.error('Error searching products:', error);
      return {
        products: [],
        total: 0,
        page: 1,
        limit: params.limit || 12,
        totalPages: 1,
        hasNextPage: false,
        hasPreviousPage: false
      };
    }
  },

  // Get products by category
  async getProductsByCategory(
    category: string,
    params: Omit<GetProductsParams, 'category'> = {}
  ): Promise<PaginatedProducts> {
    if (useMockData || isLocalDev) {
      const filtered = typedProductsMock.filter(
        product => product.category.toLowerCase() === category.toLowerCase()
      );

      const page = params.page || 1;
      const limit = params.limit || 12;
      const total = filtered.length;
      const totalPages = Math.ceil(total / limit);

      return {
        products: filtered.slice((page - 1) * limit, page * limit),
        total,
        page,
        limit,
        totalPages,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1,
      };
    }
    
    try {
      const response = await axios.get<PaginatedProducts>(
        `${PRODUCTS_ENDPOINT}/category/${encodeURIComponent(category)}`,
        { params }
      );
      return response.data;
    } catch (error) {
      console.error(`Error fetching products in category ${category}:`, error);
      return {
        products: [],
        total: 0,
        page: params.page || 1,
        limit: params.limit || 12,
        totalPages: 1,
        hasNextPage: false,
        hasPreviousPage: false
      };
    }
  }
};

export default productService;
